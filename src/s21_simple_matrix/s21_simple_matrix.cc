/* ************************************************************************** */
/*                                              ############       ####       */
/*                                              ############       ####       */
/*   s21_simple_matrix.cc                                   ####       ####   */
/*                                                          ####       ####   */
/*   By: hubertfu@student.21-school.ru              ########           ####   */
/*                                                  ########           ####   */
/*                                              ####                   ####   */
/*   Created: 2023-06-29                        ####                   ####   */
/*   Updated: 2023-06-29                            ############       ####   */
/*                                                  ############       ####   */
/* ************************************************************************** */

/**
 * @file s21_matrix_oop.cc
 * @author Hubert Furr (hubertfu@student.21-school.ru)
 * @brief см. заголовочный файл
 * @version 1.0
 * @date 2023-06-29
 *
 * @copyright School-21 (c) 2023
 *
 */

#include "./s21_simple_matrix.h"

#include <algorithm>  // std::copy
#include <stdexcept>  // std::length_error
#include <utility>    // std::swap

/**
 * @brief
 * Конструктор по умолчанию (Default constructor). Создает объект SimpleMatrix
 * размером [0 × 0], заполненный нулями.
 *
 * @details
 * Не отличается от реализации S21Matrix
 */
SimpleMatrix::SimpleMatrix() noexcept : rows_(0), cols_(0), matrix_(nullptr) {}

/**
 * @brief
 * Параметризованный конструктор (Parameterized Constructor). Создает объект
 * SimpleMatrix размером [rows × cols], заполненный нулями.
 *
 * @details
 * Не отличается от реализации S21Matrix
 *
 * @param rows Количество строк
 * @param cols Количество столбцов
 */
SimpleMatrix::SimpleMatrix(int rows, int cols) : rows_(rows), cols_(cols) {
  if (rows_ < 0 || cols_ < 0) {
    throw std::length_error("Matrix size must be greater or equal than 0");
  }
  matrix_ = new double[rows_ * cols_]{};
}

/**
 * @brief Конструктор копирования (Copy Constructor). Создает объект
 * SimpleMatrix путем копирования данных из объекта other.
 *
 * @details
 * Не отличается от реализации S21Matrix
 *
 * @param other Копируемая матрица
 */
SimpleMatrix::SimpleMatrix(const SimpleMatrix &other)
    : rows_(other.rows_),
      cols_(other.cols_),
      matrix_(new double[rows_ * cols_]) {
  std::copy(other.matrix_, other.matrix_ + rows_ * cols_, matrix_);
}

/**
 * @brief
 * Конструктор перемещения (Move Constructor). Создает объект SimpleMatrix путем
 * передачи владения ресурсами от объекта other.
 *
 * @details
 * Базовый процесс заключается в том, чтобы стать владельцем всех атрибутов
 * исходного объекта, а затем оставить его в «пустом» состоянии. То, что
 * представляет собой «пустой», будет, очевидно, варьироваться от класса к
 * классу, но в основном это означает оставить объект в таком состоянии, что его
 * деструктор не выйдет из строя или не выдаст исключение.
 *
 * По сути всё, что делает конструктор перемещения, — это замена элементов
 * исходного объекта на объект в состоянии по умолчанию.
 *
 * Тут есть небольшие несоответствия с описанием конструктора перемещения в
 * классе S21Matrix - предлагаю поразмышлять об этом самостоятельно :)
 *
 * И реализация мув-конструктора отличается от S21Matrix - здесь мы используем
 * возможность C++11 — каскадный конструктор. Сначала мы вызываем конструктор по
 * умолчанию для класса, а затем обмениваемся состоянием между this и other.
 *
 * Результат работы конструктора идентичен результату в S21Matrix, но
 * достигается это разными способами. Если поразмышлять, какой способ
 * правильнее, то:
 *
 * Вариант S21Matrix:
 * 1) Выглядит сложнее, исходный код больше, и несколько дублирует код. Это
 * означает, что есть больше шансов на ошибки/баги (в нашем случае разница не
 * кажется огромной, но в общем случае класс может быть гораздо сложнее).
 * 2) Работает быстрее - 6 сохранений в переменную, 3 считывания из переменной.
 * 3) Эффективнее и безопаснее просто задать аргументы непосредственно в объекте
 * и очистить его, как обычно (см п.3 варианта SimpleMatrix)
 *
 * Вариант SimpleMatrix:
 * 1) Вариант SimpleMatrix проще и повторно использует уже написанный нами код.
 * Это означает, что меньше шансов на ошибки/баги.
 * 2) Работает медленнее - 3 сохранения для конструктора + 9 считываний и
 * 9 сохранений для свапа (либо 6 считываний и 6 сохранений для свапа - смотря
 * как считать). Но компилятор может быть достаточно умен, чтобы оптимизировать
 * п.2 в некоторых случаях.
 * 3) Инициализация объекта дефолтным конструктором может быть расточительной,
 * выделенные любые ресурсы по умолчанию будут почти сразу же освобождены (а для
 * более сложных объектов это возможно даже для "пустых" объектов). Кроме того,
 * нельзя быть полностью уверенным, что соблюдается noexcept, если не вы пишите
 * конструктор по умолчанию или он зависит от других объектов.
 *
 *
 * Т.о. какой шаблон лучше всего подходит для создания конструктора перемещения?
 * Правильный ответ - нет идеального способа, необходимо думать головой, а не
 * следовать каким-то шаблонам без раздумий :)
 *
 *
 * Еще бы хотелось отметить, что когда ресурсы — это не просто память, а что-то
 * вроде мьютексов или потоков, семантика swap неверна.
 *
 * Но вообще умные дядьки, типа Howard Hinnant, рекомендуют все-таки swap не
 * использовать в большинстве случаев для мув-семантики. via:
 * https://stackoverflow.com/questions/6687388/why-do-some-people-use-swap-for-move-assignments
 * http://www.accu.org/content/conf2014/Howard_Hinnant_Accu_2014.pdf
 *
 * @param other Перемещаемая матрица
 */
SimpleMatrix::SimpleMatrix(SimpleMatrix &&other) noexcept : SimpleMatrix() {
  swap(other);
}

// TODO: Тут приведено максимально классическая реализация operator= таким
// образом, что "оператор присваивания перемещения не нужен!". Но у меня есть
// вопрос, на которы я пока не знаю ответа - а разве оператор присваивания не
// должен быть обязательно noexcept (C++ Core Guidelines)????
/**
 * @brief
 * Оператор присваивания (копирование и перемещение одним оператором)
 *
 * @details
 *
 * Правило Большой тройки гласит, что если вы реализовали один из методов:
 * 1) Деструктор
 * 2) Оператор присваивания
 * 3) Конструктор копирования
 * то вы также должны реализовать два других.
 *
 * Чтобы реализовать идиому Copy-Swap, ваш класс управления ресурсами также
 * должен реализовать функцию swap() для выполнения обмена между членами
 * (это та самая половина, в общем получается правило 3.5)
 *
 * Идиома Copy-Swap обеспечивает эффективный и безопасный способ реализации
 * оператора присваивания путем (повторного) использования кода конструктора
 * копирования.
 *
 * Правило большой тройки было основным до std=c++11, но после ввода
 * мув-семантики, мы теперь должны использовать правило 5 или 4.5, однако нам
 * интересно посмотреть на него для понимания правила 4.5
 *
 * Ключевые моменты:
 * 1) У нас должен быть реализован copy-конструктор
 * 2) Объект other мы передаем в оператор ИМЕННО ПО ЗНАЧЕНИЮ - в этом случае
 * создание копии other происходит при помощи copy-конструктора еще до вызова
 * оператора. Если при это будет брошено исключение, то соблюдается строгая
 * гарантия безопасности исключений - мы даже в метод еще не зашли.
 * 3) Внутри мы эффективно и безопасно используем идиому Copy-Swap. Когда
 * временный объект (который теперь содержит бывший this) выходит из области
 * видимости в конце функции он удаляется деструктором.
 *
 * Правило большой четверки (с половиной) гласит, что если вы написали одну из
 * функций:
 * 1) Деструктор
 * 2) Конструктор копирования
 * 3) Оператор присваивания
 * 4) Конструктор перемещения
 * 5) Функция swap (это опять-таки половинка)
 * то вы также должны реализовать все остальные (хотя на самом деле вы не должны
 * их писать, скорее у вас должна быть политика в отношении остальных - default
 * или delete - тоже политика)
 *
 * Самый занимательный факт - реализация operator= для правила 4.5 полностью
 * совпадает с реализацией для правила 3.5, отличие только в том, что мы у нас
 * должен быть реализован и copy-конструктор и move-конструктор, сам код
 * operator= остается тем же.
 *
 * Но как это работает? В правиле 3.5 версия оператора присваивания делала копию
 * правого объекта перед вызовом. Это вызывает обычный конструктор копирования.
 * Однако если в оператор присваивания будет передана rvalue, то вместо
 * конструктора копирования будет вызван конструктор перемещения, что оставит
 * изначальный объект в "пустом" состоянии, а далее внутри метода this и other
 * поменяются местами и при выходе из функции временный объект будет удален -
 * собственно произойдет всё то, что нам нужно.
 *
 *
 * @param other копируемый объект SimpleMatrix
 * @return SimpleMatrix&
 */
SimpleMatrix &SimpleMatrix::operator=(SimpleMatrix other) {
  swap(other);
  return *this;
}

/**
 * @brief Деструктор объекта (Destructor).
 *
 * @details
 * Не отличается от реализации S21Matrix (почти)
 */
SimpleMatrix::~SimpleMatrix() noexcept {
  delete[] matrix_;
  rows_ = 0;
  cols_ = 0;
  matrix_ = nullptr;
}

/**
 * @brief
 * Меняет 2 матрицы местами
 *
 * @details
 * А почему swap(), а не Swap()? Казалось бы Google style требует от нас второй
 * вариант. Но нет:
 * 1) Google style: "If you are naming something that is analogous to an
 * existing C or C++ entity then you can follow the existing naming convention
 * scheme."
 * 2) std::swap будет использовать функцию swap() класса, если она определена.
 * Если мы назовем Swap(), то она использовать не будет.
 */
void SimpleMatrix::swap(SimpleMatrix &other) noexcept {
  std::swap(matrix_, other.matrix_);
  std::swap(rows_, rows_);
  std::swap(cols_, cols_);
}
