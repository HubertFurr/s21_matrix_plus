Т.к. на code review в том числе оцениваются используемые алгоритмы, то алгоритм расчета определителя оцениваю как очень плохой:
1) Сложность алгоритма O(n!), а это крайне медленно, определитель матрицы 12х12 уже не посчитается за адекватное время (соответсвенно и матрица алгебраических дополнений и обратная матрица):
- n = 11 ~3сек
- n = 12 ~35сек
- n = 13 ~460сек
2) Т.к. алгоритм производит очень много рекурсивных промежуточных перемножений значений ячеек матрицы, то при использовании double точность может сильно страдать. Например при 1e7 в ячейках промежуточные результаты могут дооходить до 1e30, что явно плохо влияет на точность double
3) Алгоритм плохо просчитывает случаи, когда определитель должен быть равен 0, опять-таки из-за потери точности (заметно на матрицах 5х5 и более), причем это необязательно должны быть огромные числа, маленькие числа с большим количеством значащих цифр тоже страдают, например:

```
  S21Matrix matrix1{5, 5};

  matrix1(0, 0) = 561.395;
  matrix1(0, 1) = 356.219;
  matrix1(0, 2) = 356.219;
  matrix1(0, 3) = -952.484;
  matrix1(0, 4) = -506.042;

  matrix1(1, 0) = 370.469;
  matrix1(1, 1) = 356.219;
  matrix1(1, 2) = 356.219;
  matrix1(1, 3) = 441.733;
  matrix1(1, 4) = 919.346;

  matrix1(2, 0) = 113.190;
  matrix1(2, 1) = 356.219;
  matrix1(2, 2) = 356.219;
  matrix1(2, 3) = 577.491;
  matrix1(2, 4) = -770.006;

  matrix1(3, 0) = -629.533;
  matrix1(3, 1) = 356.219;
  matrix1(3, 2) = 356.219;
  matrix1(3, 3) = 370.425;
  matrix1(3, 4) = -226.376;

  matrix1(4, 0) = 964.659;
  matrix1(4, 1) = 356.219;
  matrix1(4, 2) = 356.219;
  matrix1(4, 3) = 907.791;
  matrix1(4, 4) = 679.804;
```

Результат должен быть 0






Добавлю пояснение, тут и везде, где второй ревьюер сделал подобный комментарий про "maybe leaks":

В конструкторе не соблюдаются базовые гарантии безопасности исключений (рекомендую почитать про это, а также про другие типы гарантий), что в определенных ситуациях чревато утечками памяти.

Пример: Сначала в строке 11 будет выделена память на строки, затем в строке 13 будет выделятся память на каждую строку. Если при этом будет брошено исключение из функции new (например, доступная память кончилась), то объект не будет создан, соответсвенно его деструктор вызываться в программе далее не будет (т.к. объекта нет), соответсвенно уже выделенную память почистить будет некому, эта память будет утечкой.

Обычно эта проблема решается одним из следующих способов:
1) Память выделяется одним куском за один вызов new
2) Память выделяется одним куском, используя аллокатор и отдельный класс буфера для управления памятью
3) Оставить как сейчас, но добавить try/catch и чистить уже выделенную память память при исключении


Я бы поспорил со всеми комментариями, где написано про необходимость std::move, кроме комментария про MulMatrix().
В MulMatrix() действительно лучше std::move, т.к. this будет обновлен перемещением, а не копированием. В остальных случаях, включая этот, спорно. Начиная с С++11 стандарт гарантирует, что если оптимизатор выключен, и NRVO не будет, то в этой ситуации будет вызван конструктор перемещения. Более того, использование std:move убирает возможность NRVO, что может быть вредно.
Исключения:

Если возвращаем часть объекта, то надо написать std::move(result.t)
Если возвращаем не имя локальной переменной или параметра, то надо написать std::move(*pt)
Если тип переменной отличается от типа возвращаемого значения, то надо писать std::move(result)

На самом деле тема очень обширная, в ней надо разбираться сидеть. Но в этом случае std::move(result) не надо



Согласен c этими словами (Статься с подробностями: https://habr.com/ru/company/vk/blog/666330/)



1) Pragma once - это нестандартная директива, компилятор не обязан её поддерживать. Поэтому не рекомендуется её использовать. Если быть совсем честным, то можно её использовать, но вместе с include guards, для написания переносимого кода, что также может принести выгоду от применения #pragma once при оптимизации (если компилятор её поддерживает). Но в данном случае используется только Pragma once, что неправильно
2) Goole style обязывает нас организовывать защиту по-другому:

> Все заголовочные файлы должны быть с защитой от повторного включения посредством #define. Формат макроопределения должен быть: <PROJECT>_<PATH>_<FILE>_H_.